<!DOCTYPE html><html lang="en" class="aspect-4-3"><head><meta charset="UTF-8"><meta name="generator" content="Asciidoctor 0.1.4, dzslides backend"><title>The Java EE 7 Platform</title><meta name="author" content="Kuba Marchwicki"><link rel="stylesheet" href="http://fonts.googleapis.com/css?family=Yanone+Kaffeesatz:400,700,200,300&amp;family=Cedarville+Cursive"><link rel="stylesheet" href="http://cdnjs.cloudflare.com/ajax/libs/font-awesome/3.2.1/css/font-awesome.min.css"><link rel="stylesheet" href="./dzslides/themes/highlight/monokai.css"><link rel="stylesheet" href="./dzslides/themes/style/stormy-jm.css"><style>section:not(.topic) > h2 { display: none;}</style><link rel="stylesheet" href="./dzslides/core/dzslides.css"><link rel="stylesheet" href="./dzslides/themes/transition/fade.css"></head><body><section class="title"><h1>The Java EE 7 Platform</h1><footer><span class="author">Kuba Marchwicki</span><span class="divider">&nbsp;&middot;&nbsp;</span><span class="author">@kubem</span></footer></section><section><div class="exampleblock"><div class="content"><blockquote><p>Perfection is achieved, not when there is nothing more to add, but when there is nothing left to take away.</p><br><cite>Antoine de Saint-Exupery</cite></blockquote></div></div></section>
<section class="topic"><h2>The story behind J(2)EE</h2><img class="middle" src="images/03-jee-history.png" alt="JEE History" width="600"></section>
<section class="topic"><h2>JEE6 profiles</h2><img class="middle" src="images/04-jee6-profiles.png" alt="JEE Profiles" width="600">
<details><details open=""><p>Problems. Tomee (web profile), Tomee + JAX-RS, Tomee Plus (Full profile). Więc w JEE7 JAX-RS przewędrował do web profile.</p></details></details></section>
<section class="topic"><h2>JEE7</h2><img class="middle" src="images/05-jee7-deep-dive.png" alt="JEE7" width="600">
<details><details open=""><ul><li>Cel: modernizacja API</li><li>Co nie weszło: JCache – JSR 107</li></ul></details></details></section>
<section class="topic"><h2>JEE7 deep dive</h2><img class="middle" src="images/06-jee7-deep-dive.png" alt="JEE7" width="600"></section>
<section><figure><img class="stretch-x" src="images/07-whats-all-about.png" alt="07 whats all about"><figcaption>What's it all about?</figcaption></figure>
<details><details open=""><ul><li>An umbrella specification.</li><li>Nothing new – just made sure all specs talk to each other</li></ul></details></details></section>
<section class="topic"><h2>JEE7 deep dive</h2><ul class="incremental"><li>JMS 2.0</li><li>JPA 2.1</li><li>Bean Validation 1.1</li><li>JAX-RS 2.0</li><li>Java API for JSON Processing</li><li>Java API for Websockets</li><li>Batch Applications</li><li>Concurrency Utilities</li></ul>
<details><details open=""><p>Out of scope:</p>
<ul><li>JTA 1.2 i adnotacji <code>@Transactional</code> pozwalającej objąć transakcją także komponenty CDI</li><li>JSF 2.2. <code>@FlowScope</code> oraz przepuszczanie atrybutów i elementów (pod kątem HTML5) - nie utrudnia</li><li>CDI 1.1 - uruchomienie <em>by default</em> przez co były problemy z Google Guice. Adnotacja <code>@Vetoed</code></li></ul>
<p>In scope: <strong>JMS</strong> configuration. <strong>JPA</strong> converters. <strong>Validaton</strong> method params.
<strong>JAX-RS</strong> client API &amp; configuration. <strong>JSON</strong> streaming and object API. <strong>Websockets</strong> <strong>Batch</strong> ETL <strong>Concurrency</strong></p></details></details></section>
<section class="topic source"><h2>Before we start</h2><div class="listingblock"><pre class="highlight"><code class="xml">&lt;dependency&gt;
  &lt;groupId&gt;javax&lt;/groupId&gt;
  &lt;artifactId&gt;javaee-api&lt;/artifactId&gt;
  &lt;version&gt;7.0&lt;/version&gt;
  &lt;scope&gt;provided&lt;/scope&gt;
&lt;/dependency&gt;</code></pre></div>
<details><details open=""><ul><li>Maven dependency. Nie ma problemów – co szczególnie było widoczne w testach. Gdzie można było budować unit testy bez kontenera</li><li>java.lang.ClassFormatError: Absent Code attribute in method that is not native or abstract in class file javax/persistence/LockModeType</li></ul></details></details></section>
<section class="topic"><h2>JEE7 deep dive</h2><ul><li><strong>JMS 2.0</strong></li><li>JPA 2.1</li><li>Bean Validation 1.1</li><li>JAX-RS 2.0</li><li>Java API for JSON Processing</li><li>Java API for Websockets</li><li>Batch Applications</li><li>Concurrency Utilities</li></ul>
<details><details open=""><ul><li>JCA Adapter – czyli możemy wymieniać implementacje: websphere z RabbitMQ</li><li>New JMSContext interface</li><li>AutoCloseable JMSContext, Connection, Session, …</li><li>Use of runtime exceptions</li><li>Method chaining on JMSProducer</li><li>Simplified message sending</li></ul></details></details></section>
<section class="topic"><h2>JMS 2.0 :: Configuration - Old API</h2><p class="statement middle"><strong>?</strong></p></section>
<section class="topic source"><h2>JMS 2.0 :: Configuration - Old API</h2><div class="listingblock"><pre class="highlight"><code class="xml">&lt;subsystem xmlns="urn:jboss:domain:messaging:1.1"&gt;
  &lt;hornetq-server&gt;
     &lt;jms-destinations&gt;
        &lt;jms-queue name="testQueue"&gt;
            &lt;entry name="queue/test"/&gt;
        &lt;/jms-queue&gt;
        &lt;jms-topic name="testTopic"&gt;
            &lt;entry name="topic/test"/&gt;
        &lt;/jms-topic&gt;
     &lt;/jms-destinations&gt;
  &lt;/hornetq-server&gt;
&lt;/subsystem&gt;</code></pre></div></section>
<section class="topic source"><h2>JMS 2.0 :: Configuration - New API</h2><div class="listingblock"><pre class="highlight"><code class="java">
@JMSConnectionFactoryDefinition( <i class="conum" data-value="1"></i><b>(1)</b>
  name = "java:global/jms/demoConnectionFactory",
  className = "javax.jms.ConnectionFactory")
@JMSDestinationDefinition( <i class="conum" data-value="2"></i><b>(2)</b>
  name = "java:global/jms/demoQueue",
  interfaceName = "javax.jms.Queue",
  destinationName = "demoQueue")
public class JmsConfiguration {

}</code></pre></div>
<div class="colist arabic"><table><tr><td><i class="conum" data-value="1"></i><b>1</b></td><td>Use annotation to specify a JMS <code>ConnectionFactory</code></td></tr><tr><td><i class="conum" data-value="2"></i><b>2</b></td><td>Use annotation to specify a JMS <code>Destination</code></td></tr></table></div></section>
<section class="topic source"><h2>JMS 2.0 :: Sending messages - Old API</h2><div class="listingblock"><pre class="highlight"><code class="java">@Stateless
public class SendMessageService {

  @Resource(lookup = "java:global/jms/demoConnectionFactory")
  ConnectionFactory connectionFactory;
  @Resource(lookup = "java:global/jms/demoQueue")
  Queue demoQueue;

  public void sendMessage(String payload) {
     try {
        Connection connection = connectionFactory.createConnection();
        Session session = connection
            .createSession(false, Session.AUTO_ACKNOWLEDGE);
        MessageProducer messageProducer = session
            .createProducer(demoQueue);
        TextMessage textMessage = session.createTextMessage(payload);
        messageProducer.send(textMessage); <i class="conum" data-value="1"></i><b>(1)</b>
     } finally {
        //...
     }
  }
}</code></pre></div>
<div class="colist arabic"><table><tr><td><i class="conum" data-value="1"></i><b>1</b></td><td>This is the only important line</td></tr></table></div></section>
<section class="topic source"><h2>JMS 2.0 :: Sending messages - New API</h2><div class="listingblock"><pre class="highlight"><code class="java">@Stateless
public class MessageService {

  @Inject
  private JMSContext context; <i class="conum" data-value="1"></i><b>(1)</b>
  @Resource(mappedName = "jms/inboundQueue")
  private Queue inboundQueue;

  public void sendMessage(String payload) {
     context.createProducer().send(inboundQueue, payload); <i class="conum" data-value="2"></i><b>(2)</b>
  }

}</code></pre></div>
<div class="colist arabic"><table><tr><td><i class="conum" data-value="1"></i><b>1</b></td><td>Injecting a complete context</td></tr><tr><td><i class="conum" data-value="2"></i><b>2</b></td><td>Spring inspired <code>*Template</code> class</td></tr></table></div>
<details><details open=""><p>Inspiracja JmsTemplate Springowym jest dość oczywista. I w ogóle całą klasą klas *Template ze Springa
Likwidujemy checked expections.</p>
<p>It is close to Spring JmsTemplate features
Reduces boilerplate code, Manages resources transparently, Handles exception properly,
Converts checked exceptions to runtime equivalents, Provides convenience methods such
as the convertAndSend() method that take a destination (a queue here) and a payload
object as message.</p></details></details></section>
<section class="topic source"><h2>JMS 2.0 :: Reciving message - New API</h2><div class="listingblock"><pre class="highlight"><code class="java">@MessageDriven(mappedName="global/jms/demoQueue")
public class MessageConsumer implements MessageListener {

  @Override
  public void onMessage(Message msg) {
     try {
       String payload = msg.getBody(String.class); <i class="conum" data-value="1"></i><b>(1)</b>
     } catch (JMSException e) {
        e.printStackTrace();
     }
  }
}</code></pre></div>
<div class="colist arabic"><table><tr><td><i class="conum" data-value="1"></i><b>1</b></td><td>No casting!!!</td></tr></table></div>
<details><details open=""><p>Not much changed - no casting</p></details></details></section>
<section><img class="middle" src="images/17-jms.png" alt="17 jms" width="600">
<details><details open=""><p>Nice try Oracle!</p></details></details></section>
<section class="topic"><h2>JEE7 deep dive</h2><ul><li>JMS 2.0</li><li><strong>JPA 2.1</strong></li><li>Bean Validation 1.1</li><li>JAX-RS 2.0</li><li>Java API for JSON Processing</li><li>Java API for Websockets</li><li>Batch Applications</li><li>Concurrency Utilities</li></ul>
<details><details open=""><p>Criteria API niestety nadal wygląda tak że się trochę odechciewa.
Ale pojawiło się parę uproszczeń:</p>
<ul><li>configuracja</li><li>stored procedured</li><li>converters</li></ul></details></details></section>
<section class="topic source"><h2>JPA 2.1 :: Old Api - persistence.xml</h2><div class="listingblock"><pre class="highlight"><code class="java">&lt;persistence-unit&gt;
  &lt;properties&gt;
    &lt;property name="hibernate.connection.driver_class" <i class="conum" data-value="1"></i><b>(1)</b>
       value="org.apache.derby.jdbc.ClientDriver" /&gt;
    &lt;property name="hibernate.connection.url" <i class="conum" data-value="2"></i><b>(2)</b>
       value="jdbc:derby://localhost:1527/sample;create=true" /&gt;
    &lt;property name="hibernate.connection.username" value="user" /&gt; <i class="conum" data-value="3"></i><b>(3)</b>
    &lt;property name="hibernate.connection.password" value="pass" /&gt; <i class="conum" data-value="4"></i><b>(4)</b>
    &lt;property name="hibernate.show_sql" value="true" /&gt; <i class="conum" data-value="5"></i><b>(5)</b>
    &lt;property name="hibernate.format_sql" value="true" /&gt; <i class="conum" data-value="6"></i><b>(6)</b>
    &lt;property name="hibernate.use_sql_comments" value="true" /&gt; <i class="conum" data-value="7"></i><b>(7)</b>
    &lt;property name="hibernate.dialect" <i class="conum" data-value="8"></i><b>(8)</b>
       value="org.hibernate.dialect.MySQL5Dialect" /&gt;
    &lt;property name="hibernate.hbm2ddl.auto" value="create-drop" /&gt; <i class="conum" data-value="9"></i><b>(9)</b>
  &lt;/properties&gt;
&lt;/persistence-unit&gt;
</code></pre></div></section>
<section class="topic source"><h2>JPA 2.1 :: Old Api - persistence.xml</h2><div class="listingblock"><pre class="highlight"><code class="java">&lt;persistence-unit&gt;
  &lt;properties&gt;
    &lt;property name="eclipselink.jdbc.driver" <i class="conum" data-value="1"></i><b>(1)</b>
      value="org.apache.derby.jdbc.ClientDriver" /&gt;
    &lt;property name="eclipselink.jdbc.url" <i class="conum" data-value="2"></i><b>(2)</b>
      value="jdbc:derby://localhost:1527/sample;create=true" /&gt;
    &lt;property name="eclipselink.jdbc.user" value="user" /&gt; <i class="conum" data-value="3"></i><b>(3)</b>
    &lt;property name="eclipselink.jdbc.password" value="pass" /&gt; <i class="conum" data-value="4"></i><b>(4)</b>
    &lt;property name="eclipselink.logging.level" value="FINE" /&gt; <i class="conum" data-value="5"></i><b>(5)</b>
    &lt;property name="eclipselink.target-database" <i class="conum" data-value="6"></i><b>(6)</b>
      value="org.eclipse.persistence.platform.database.MySQLPlatform" /&gt;
    &lt;property name="eclipselink.ddl-generation" <i class="conum" data-value="7"></i><b>(7)</b>
      value="drop-and-create-tables" /&gt;
    &lt;property name="eclipselink.ddl-generation.output-mode" <i class="conum" data-value="8"></i><b>(8)</b>
      value="database" /&gt;
  &lt;/properties&gt;
&lt;/persistence-unit&gt;
</code></pre></div></section>
<section class="topic source"><h2>JPA 2.1 :: New API - persistence.xml</h2><div class="listingblock"><pre class="highlight"><code class="java">&lt;persistence-unit&gt;
  &lt;properties&gt;
    &lt;property name="javax.persistence.jdbc.driver"
      value="org.apache.derby.jdbc.ClientDriver" /&gt; <i class="conum" data-value="1"></i><b>(1)</b>
    &lt;property name="javax.persistence.jdbc.url"
      value="jdbc:derby://localhost:1527/sample;create=true" /&gt; <i class="conum" data-value="2"></i><b>(2)</b>
    &lt;property name="javax.persistence.jdbc.user" value="user" /&gt; <i class="conum" data-value="3"></i><b>(3)</b>
    &lt;property name="javax.persistence.jdbc.password" value="pass" /&gt; <i class="conum" data-value="4"></i><b>(4)</b>
    &lt;property name="javax.persistence.schema-generation.database.action"
      value="drop-and-create" /&gt; <i class="conum" data-value="5"></i><b>(5)</b>

    &lt;property name="eclipselink.logging.level" value="FINE" /&gt;
    &lt;property name="eclipselink.target-database"
      value="org.eclipse.persistence.platform.database.MySQLPlatform" /&gt;
  &lt;/properties&gt;
&lt;/persistence-unit&gt;
</code></pre></div></section>
<section class="topic source"><h2>JPA 2.1 :: Old API - convertions</h2><div class="listingblock"><div class="title"><code>UserSex.java</code></div><pre class="highlight"><code class="java">public enum UseSex {
  MALE, FEMALE;
}</code></pre></div>
<div class="listingblock"><div class="title"><code>User.java</code></div><pre class="highlight"><code class="java">@Entity
public class User {

  @Id
  private long id;

  @Enumerated(EnumType.ORDINAL) <i class="conum" data-value="1"></i><b>(1)</b>
  private UserSex sex;

  //..
}</code></pre></div>
<div class="colist arabic"><table><tr><td><i class="conum" data-value="1"></i><b>1</b></td><td>Actual database value is either <code>0</code> or <code>1</code></td></tr></table></div>
<details><details open=""><p>Ale znacznie częściej w bazie mam “M” I “F” – bo tak chciał dba</p></details></details></section>
<section class="topic source"><h2>JPA 2.1 :: Old API - convertions</h2><div class="listingblock"><div class="title"><code>UserSex.java</code></div><pre class="highlight"><code class="java">public enum UseSex {
  MALE, FEMALE;
}</code></pre></div>
<div class="listingblock"><div class="title"><code>User.java</code></div><pre class="highlight"><code class="java">@Entity
public class User {

  @Id
  private long id;

  @Enumerated(EnumType.STRING) <i class="conum" data-value="1"></i><b>(1)</b>
  private UserSex sex;

  //..
}</code></pre></div>
<div class="colist arabic"><table><tr><td><i class="conum" data-value="1"></i><b>1</b></td><td>Actual database value is either <code>MALE</code> or <code>FEMALE</code></td></tr></table></div>
<details><details open=""><p>Wciąż to nie to co powinienem. Jak ro rozwiązać</p></details></details></section>
<section class="topic source"><h2>JPA 2.1 :: Old API - convertions</h2><div class="listingblock"><pre class="highlight"><code class="java">@Entity
public class User {

  @PostLoad
  public void afterLoad() {
    switch(db_sex){
      case "M": sex = UserSex.MALE;
      case "F": sex = UserSex.FEMALE;
      default: throw new IllegalArgumentException();
    }
  }

  @PrePersist
  public void beforePersit() {
    switch(sex){
      case MALE: db_sex = "M";
      case FEMALE: db_sex = "F";
      default: throw new IllegalArgumentException();
    }
  }
}</code></pre></div></section>
<section class="topic source"><h2>JPA 2.1 :: New API - convertions</h2><div class="listingblock"><pre class="highlight"><code class="java">@Entity
public class User {

  @Convert(converter = SexConverter.class) <i class="conum" data-value="1"></i><b>(1)</b>
  private UserSex sex;

  //..
}</code></pre></div>
<div class="colist arabic"><table><tr><td><i class="conum" data-value="1"></i><b>1</b></td><td>Declare converter</td></tr></table></div></section>
<section class="topic source"><h2>JPA 2.1 :: New API - convertions</h2><div class="listingblock"><pre class="highlight"><code class="java">@Converter <i class="conum" data-value="1"></i><b>(1)</b>
public class SexConverter
  implements AttributeConverter&lt;UserSex, String&gt; { <i class="conum" data-value="2"></i><b>(2)</b>

  public String convertToDatabaseColumn(UserSex arg0) {
    switch(arg0){
      case MALE: return "M";
      case FEMALE: return "F";
      default: throw new IllegalArgumentException();
    }
  }

  public UserSex convertToEntityAttribute(String arg0) {
    switch(arg0){
      case "M": return UserSex.MALE;
      case "F": return UserSex.FEMALE;
      default: throw new IllegalArgumentException();
    }
  }
}</code></pre></div></section>
<section class="topic source"><h2>JPA 2.1 :: New API - stored procedures</h2><div class="listingblock"><pre class="highlight"><code class="java">@Table(indexes = @Index(columnList = "name")) <i class="conum" data-value="1"></i><b>(1)</b>
@Entity
@NamedQuery(name = User.FIND_USER_BY_NAME,
   query = "from User u where name = ?")
@NamedStoredProcedureQuery(name = User.REFRESH_USERS,
   procedureName = "USR_STRD_PRCR_CALL") <i class="conum" data-value="2"></i><b>(2)</b>
public class User {
   public final static String FIND_USER_BY_NAME = "User.findByName";
   public final static String REFRESH_USERS = "User.refreshUsersEntries";

   //..

}</code></pre></div>
<div class="colist arabic"><table><tr><td><i class="conum" data-value="1"></i><b>1</b></td><td>Define indexes for schema generation</td></tr><tr><td><i class="conum" data-value="2"></i><b>2</b></td><td>Use predefined stored procedures</td></tr></table></div></section>
<section class="topic"><h2>JEE7 deep dive</h2><ul><li>JMS 2.0</li><li>JPA 2.1</li><li><strong>Bean Validation 1.1</strong></li><li>JAX-RS 2.0</li><li>Java API for JSON Processing</li><li>Java API for Websockets</li><li>Batch Applications</li><li>Concurrency Utilities</li></ul>
<details><details open=""><p>I&#8217;ll focus on two areas: method level (parameters) validation and JAX-RS services validation</p></details></details></section>
<section class="topic source"><h2>Validation 1.1 :: Old API - method parameters</h2><div class="listingblock"><pre class="highlight"><code class="java">@Interceptors(ValidationInterceptor.class) <i class="conum" data-value="1"></i><b>(1)</b>
public void addAuthor(String name,
	@Size(min=5) String surename) { <i class="conum" data-value="2"></i><b>(2)</b>
   Author a = new Author();
   a.setName(name);
   a.setSurename(surename);

   em.persist(a);
}</code></pre></div>
<div class="colist arabic"><table><tr><td><i class="conum" data-value="1"></i><b>1</b></td><td>Interceptor is needed cause AppServer does not handle such case</td></tr><tr><td><i class="conum" data-value="2"></i><b>2</b></td><td>Validation annotations can be used for method params</td></tr></table></div></section>
<section class="topic source"><h2>Validation 1.1 :: Old API - method parameters</h2><div class="listingblock"><pre class="highlight"><code class="java">public Object validateMethodInvocation(InvocationContext ctx)
    throws Exception { <i class="conum" data-value="1"></i><b>(1)</b>

    MethodValidator validator = validatorFactory.getValidator()
        .unwrap(MethodValidator.class);

    Set&lt;MethodConstraintViolation&lt;Object&gt;&gt; violations =
        validator.validateAllParameters(
            ctx.getTarget(),
            ctx.getMethod(),
            ctx.getParameters());

   //...

}</code></pre></div>
<div class="colist arabic"><table><tr><td><i class="conum" data-value="1"></i><b>1</b></td><td>Pretty standard EJB 3.0 interception method</td></tr></table></div>
<details><details open=""><p>Mamy klasyczny interceptor, który musimy implementować</p></details></details></section>
<section class="topic source"><h2>Validation 1.1 :: New API - method parameters</h2><div class="listingblock"><pre class="highlight"><code class="java">public void addAuthor(String name,
	@Size(min=5) String surename) { <i class="conum" data-value="1"></i><b>(1)</b>

   Author a = new Author();
   a.setName(name);
   a.setSurename(surename);

   em.persist(a);
}</code></pre></div>
<div class="colist arabic"><table><tr><td><i class="conum" data-value="1"></i><b>1</b></td><td>Validation is handled out-of-the-box</td></tr></table></div>
<details><details open=""><p>Nie potrzebujemy implementować interceptorów. Walidacja działa na wszystkich typach serwisów</p></details></details></section>
<section class="topic source"><h2>Validation 1.1 :: New API - method parameters</h2><div class="listingblock"><pre class="highlight"><code class="java">@Path("/hello")
public class HelloWorld {

   @Path("/{name}")
   @GET
   @Produces(MediaType.APPLICATION_JSON)
   public JsonObject sayHello(
      @NotEmpty @PathParam("name") String name) { <i class="conum" data-value="1"></i><b>(1)</b>
         //..
      }
   }
}
</code></pre></div>
<details><details open=""><p>Tutaj np. JAX-RS. Gdy nie uda się walidacja, zwracany jest HTTP400 – Bad Request</p></details></details></section>
<section class="topic"><h2>JEE7 deep dive</h2><ul><li>JMS 2.0</li><li>JPA 2.1</li><li>Bean Validation 1.1</li><li><strong>JAX-RS 2.0</strong></li><li>Java API for JSON Processing</li><li>Java API for Websockets</li><li>Batch Applications</li><li>Concurrency Utilities</li></ul>
<details><details open=""><p>Podobnie jak z innymi elemantami specyfikacji – to jest ustandaryzowanie rzeczy które już sa obecne
RESTeasy, Jersey, CXF</p>
<p>Mamy nowe: interceptory i filtry. Tak jak w komponentach EJB i w serwletach.
Asynchroniczność – analogiczna jak AsyncServlet w Servler 3.0 (JEE6)
Niemniej - skupię się na dwóch elementach: konfiguracji oraz Client API</p>
<p>It provides a higher-level API than HttpURLConnection as well as integration with JAX-RS providers.</p></details></details></section>
<section class="topic"><h2>JAX-RS 2.0 :: Configuration - Old API</h2><p class="statement middle"><strong>?</strong></p></section>
<section class="topic source"><h2>JAX-RS 2.0 :: Configuration - Old API</h2><div class="listingblock"><pre class="highlight"><code class="xml">&lt;servlet&gt;
    &lt;servlet-name&gt;JAX-RS Servlet&lt;/servlet-name&gt;
    &lt;servlet-class&gt;
    	com.sun.jersey.spi.container.servlet.ServletContainer
    &lt;/servlet-class&gt;
    &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;
&lt;/servlet&gt;
&lt;servlet-mapping&gt;
    &lt;servlet-name&gt;JAX-RS Servlet&lt;/servlet-name&gt;
    &lt;url-pattern&gt;/jax-rs/*&lt;/url-pattern&gt;
&lt;/servlet-mapping&gt;
</code></pre></div>
<details><details open=""><p>Glassfish3, Jersey configuration</p></details></details></section>
<section class="topic source"><h2>JAX-RS 2.0 :: Configuration - New API</h2><div class="listingblock"><pre class="highlight"><code class="java">import javax.ws.rs.ApplicationPath;
import javax.ws.rs.core.Application;

@ApplicationPath("/rs") <i class="conum" data-value="1"></i><b>(1)</b>
public class RestApp extends Application { <i class="conum" data-value="2"></i><b>(2)</b>
}</code></pre></div>
<div class="colist arabic"><table><tr><td><i class="conum" data-value="1"></i><b>1</b></td><td>Root application path</td></tr><tr><td><i class="conum" data-value="2"></i><b>2</b></td><td>Extends <code>Application</code></td></tr></table></div></section>
<section class="topic source"><h2>JAX-RS 2.0 :: Client - Old API</h2><div class="listingblock"><pre class="highlight"><code class="java">HttpURLConnection connection =
   (HttpURLConnection)serverAddress.openConnection();
connection.setRequestMethod("GET");
connection.setDoOutput(true);
connection.setReadTimeout(10000);

BufferedReader rd = new BufferedReader(
   new InputStreamReader(connection.getInputStream()));
StringBuilder sb = new StringBuilder();

while ((line = rd.readLine()) != null) {
   sb.append(line + '\n');
}

System.out.println(sb.toString());</code></pre></div></section>
<section class="topic source"><h2>JAX-RS 2.0 :: Client - Old API</h2><div class="listingblock"><div class="title"><code>pom.xml</code></div><pre class="highlight"><code class="xml">&lt;dependency&gt;
	&lt;groupId&gt;com.github.kevinsawicki&lt;/groupId&gt;
	&lt;artifactId&gt;http-request&lt;/artifactId&gt;
	&lt;version&gt;5.4.1&lt;/version&gt;
&lt;/dependency&gt;</code></pre></div>
<div class="listingblock"><pre class="highlight"><code class="java">HttpRequest request = HttpRequest.get(baseURL).receive(output);
System.out.println(request.toString());</code></pre></div></section>
<section class="topic source"><h2>JAX-RS 2.0 :: Client - New API</h2><div class="listingblock"><pre class="highlight"><code class="java">import javax.ws.rs.client.Client;
import javax.ws.rs.client.ClientBuilder;
import javax.ws.rs.client.WebTarget;

Client client = ClientBuilder.newBuilder().build(); <i class="conum" data-value="1"></i><b>(1)</b>
WebTarget target = client.target(uri.toString());
Response response = target.request().get(); <i class="conum" data-value="2"></i><b>(2)</b>

assertThat(response.getStatus()).isEqualTo(200); <i class="conum" data-value="3"></i><b>(3)</b>
assertThat(target.request().get(String.class))
	.isEqualTo("{}"); <i class="conum" data-value="4"></i><b>(4)</b></code></pre></div>
<div class="colist arabic"><table><tr><td><i class="conum" data-value="1"></i><b>1</b></td><td>Prepare a client</td></tr><tr><td><i class="conum" data-value="2"></i><b>2</b></td><td>Actual request</td></tr><tr><td><i class="conum" data-value="3"></i><b>3</b></td><td>Get HTTP Response status</td></tr><tr><td><i class="conum" data-value="4"></i><b>4</b></td><td>Get the response body as String</td></tr></table></div></section>
<section class="topic"><h2>JEE7 deep dive</h2><ul><li>JMS 2.0</li><li>JPA 2.1</li><li>Bean Validation 1.1</li><li>JAX-RS 2.0</li><li><strong>Java API for JSON Processing</strong></li><li>Java API for Websockets</li><li>Batch Applications</li><li>Concurrency Utilities</li></ul></section>
<section class="topic"><h2>JSON Processing :: Old API</h2><p class="statement middle"><strong>?</strong></p></section>
<section class="topic"><h2>JSON Processing API</h2><ul class="incremental"><li>API to parse and generate JSON</li><li>Streaming API<ul><li>Low-level, efficient way to parse/generate JSON</li><li>Similar to StAX API</li></ul></li><li>Object Model API<ul><li>Simple, easy to use high-level API</li><li>Similar to DOM API</li></ul></li></ul>
<details><details open=""><p>Lowlevel API.
To nie jest JAXB dla XMLa, bardziej DOM – obiektowy, albo StAX – parser (pooling)
Wysokopoziomowy jest Jackson, GSON.
JSON binding w kolejnym kroku</p></details></details></section>
<section class="topic source"><h2>JSON Processing</h2><div class="listingblock"><pre class="highlight"><code class="json">{
	"data": [
		"Hello Jakub",
		"Guten Tag Jakub"
		]
}</code></pre></div></section>
<section class="topic source"><h2>Streaming API</h2><div class="listingblock"><pre class="highlight"><code class="java">JsonParser parser = Json.
	createParser(new StringReader(string))); <i class="conum" data-value="1"></i><b>(1)</b>

JsonParser.Event event = p.next();          // START_OBJECT
event = p.next();                           // KEY_NAME
event = p.next();                           // VALUE_STRING

assertThat(event).is(new Condition&lt;Object&gt;() {
	public boolean matches(Object value) {
		return value instanceof Event
			&amp;&amp; value == Event.VALUE_STRING; <i class="conum" data-value="2"></i><b>(2)</b>
	}
});
assertThat(parser.getString()).isEqualTo("Hello Jakub"); <i class="conum" data-value="3"></i><b>(3)</b>
</code></pre></div>
<div class="colist arabic"><table><tr><td><i class="conum" data-value="1"></i><b>1</b></td><td>Define an events based parser</td></tr><tr><td><i class="conum" data-value="2"></i><b>2</b></td><td>Look for an event (<code>START_OBJECT</code>, <code>START_ARRAY</code>, <code>KEY_NAME</code>, <code>VALUE_STRING</code>, etc)</td></tr><tr><td><i class="conum" data-value="3"></i><b>3</b></td><td>Get actual value</td></tr></table></div></section>
<section class="topic source"><h2>Object API</h2><div class="listingblock"><pre class="highlight"><code class="java">JsonReader reader = Json.
	createReader(new StringReader(string)); <i class="conum" data-value="1"></i><b>(1)</b>

JsonObject obj = reader.readObject(); <i class="conum" data-value="2"></i><b>(2)</b>
assertThat(obj.containsKey("data")).isTrue();

JsonArray results = obj.getJsonArray("data"); <i class="conum" data-value="3"></i><b>(3)</b>

assertThat(results.size()).isEqualTo(2);
assertThat(results.getString(0)).isEqualTo("Hello Jakub");
assertThat(results.getString(1)).isEqualTo("Guten tag Jakub");</code></pre></div>
<div class="colist arabic"><table><tr><td><i class="conum" data-value="1"></i><b>1</b></td><td>Create a reader</td></tr><tr><td><i class="conum" data-value="2"></i><b>2</b></td><td>Read a JSON Object</td></tr><tr><td><i class="conum" data-value="3"></i><b>3</b></td><td>Read a JSON Array</td></tr></table></div></section>
<section class="topic source"><h2>Assemblers and builders</h2><div class="listingblock"><pre class="highlight"><code class="java">import javax.json.Json; <i class="conum" data-value="1"></i><b>(1)</b>
import javax.json.JsonObject;

@Path("/simple/{name}")
@GET
@Produces(MediaType.APPLICATION_JSON)
public JsonObject saySimpleHello(@PathParam("name") String name) {
	return Json.createObjectBuilder() <i class="conum" data-value="2"></i><b>(2)</b>
		.add("data", Json.createArrayBuilder() <i class="conum" data-value="3"></i><b>(3)</b>
			.add("Hello " + name)
			.add("Guten tag " + name)
			.build())
		.build();
}
</code></pre></div>
<div class="colist arabic"><table><tr><td><i class="conum" data-value="1"></i><b>1</b></td><td>Look after <code>javax.json.*</code> package</td></tr><tr><td><i class="conum" data-value="2"></i><b>2</b></td><td>Create a builder object</td></tr><tr><td><i class="conum" data-value="3"></i><b>3</b></td><td>Work with arrays in a similar fashion</td></tr></table></div></section>
<section class="topic"><h2>JEE7 deep dive</h2><ul><li>JMS 2.0</li><li>JPA 2.1</li><li>Bean Validation 1.1</li><li>JAX-RS 2.0</li><li>Java API for JSON Processing</li><li><strong>Java API for Websockets</strong></li><li>Batch Applications</li><li>Concurrency Utilities</li></ul>
<details><details open=""><p>Z JEE7 to było moje trzecie podejście do websockets. Od wczesnej bety, po teraz. Każde kolejne ma inne API. A mówicie że Java zmienia się bardzo powoli.</p></details></details></section>
<section class="topic"><h2>Java API for Websockets</h2><ul class="incremental"><li>Server and Client WebSocket Endpoint:<ul><li><code>@ServerEndpoint</code></li><li><code>@ClientEndpoint</code></li></ul></li><li>Lifecycle methods<ul><li><code>@OnOpen</code>, <code>@OnClose</code>, <code>@OnError</code>, <code>@OnMessage</code></li></ul></li><li>Packaging and Deployment</li></ul></section>
<section class="topic source"><h2>Websockets :: Old API #1</h2><div class="listingblock"><div class="title"><code>WebSocketServlet.java</code></div><pre class="highlight"><code class="java">@WebServlet(urlPatterns = "/ping")
public class FeedNotifierWebSocket extends WebSocketServlet { <i class="conum" data-value="1"></i><b>(1)</b>

	protected StreamInbound createWebSocketInbound(
			String subprotocol,
			HttpServletRequest req) {
		//.. return new Inboud for each client
	}

}</code></pre></div></section>
<section class="topic source"><h2>Websockets :: Old API #1</h2><div class="listingblock"><pre class="highlight"><code class="java">class NotificationInbound extends MessageInbound {

	private WsOutbound outbound;

	protected void onOpen(WsOutbound outbound) {
		this.outbound = outbound; <i class="conum" data-value="1"></i><b>(1)</b>
	}

	protected void onBinaryMessage(ByteBuffer m) {
		outbound.writeBinaryMessage(message);
	}

	protected void onTextMessage(CharBuffer m) {
		outbound.writeTextMessage(message); <i class="conum" data-value="2"></i><b>(2)</b>
	}
}</code></pre></div>
<details><details open=""><p>Message Inbound was an abstraction over HTTP web socket communication
This was early Tomcat 7.0.20+ - if I recon corretly</p></details></details></section>
<section class="topic source"><h2>Websockets :: Old API #2</h2><div class="listingblock"><pre class="highlight"><code class="java">@Singleton <i class="conum" data-value="1"></i><b>(1)</b>
@WebSocketEndpoint(path=”/chat”) <i class="conum" data-value="2"></i><b>(2)</b>
public class ChatServer {
	Set&lt;Session&gt; peers = new HashSet&lt;&gt;();

	@WebSocketOpen
	public void onOpen(Session s) {
		peers.add(s);
	}

	@WebSocketClose
	public void onClose(Session s) {
		peers.remove(s);
	}

	@WebSocketMessage <i class="conum" data-value="3"></i><b>(3)</b>
	public void message(String m, Session c) throws IOException {
		for (Session session : peers) {
			if (!session.equals(c)) <i class="conum" data-value="4"></i><b>(4)</b>
				session.getRemote().sendObject(m);
		}
	}
}
</code></pre></div>
<div class="colist arabic"><table><tr><td><i class="conum" data-value="1"></i><b>1</b></td><td>More JEE&#8217;ish approach</td></tr><tr><td><i class="conum" data-value="2"></i><b>2</b></td><td>Clear Web Socket definition</td></tr><tr><td><i class="conum" data-value="3"></i><b>3</b></td><td>Handling the communication</td></tr><tr><td><i class="conum" data-value="4"></i><b>4</b></td><td>Sending the message</td></tr></table></div></section>
<section class="topic source"><h2>Websockets :: New API</h2><div class="listingblock"><pre class="highlight"><code class="java">@Singleton <i class="conum" data-value="1"></i><b>(1)</b>
@ServerEndpoint("/ping") <i class="conum" data-value="2"></i><b>(2)</b>
public class NotificationServer {
	Set&lt;Session&gt; peers = new HashSet&lt;&gt;();

	@OnOpen
	public void onOpen(Session s) throws IOException {
		peers.add(s);
	}

	@OnClose
	public void onClose(Session s) throws IOException {
		peers.remove(s);
	}

	@OnMessage <i class="conum" data-value="3"></i><b>(3)</b>
	public void message(String m, Session c) throws IOException {
		for (Session session: peers) {
			if (!session.equals(c)) <i class="conum" data-value="4"></i><b>(4)</b>
				session.getBasicRemote().sendText(m);
		}
	}
}</code></pre></div>
<details><details open=""><p>Cel: abstrakcja komunikacji TCP, tak jak JAX-RS jest abstrakcją na komunikację HTTP
Sesja jest kowersacją</p>
<p>Przykład LIVE!!</p>
<p>API names has changed - and that&#8217;s pretty much all.</p></details></details></section>
<section class="topic"><h2>JEE7 deep dive</h2><ul><li>JMS 2.0</li><li>JPA 2.1</li><li>Bean Validation 1.1</li><li>JAX-RS 2.0</li><li>Java API for JSON Processing</li><li>Java API for Websockets</li><li><strong>Batch Applications</strong></li><li>Concurrency Utilities</li></ul></section>
<section class="topic"><h2>Batch Applications</h2><ul class="incremental"><li>Suited for non-interactive, bulk-oriented, and long-running tasks</li><li>Batch execution: sequential, parallel, decision-based</li><li>ETL processes: Extract, Transform, Load</li></ul></section>
<section><dl class="incremental"><dt>Job Repository</dt><dd>holds information about jobs current running and jobs that run in the past. JobOperator provides access to this repository.</dd><dt>Job Operator</dt><dd>an interface to manage all aspects of job processing, including operational commands, such as start, restart, and stop, retrieval of job and step executions.</dd><dt>Job</dt><dd>encapsulates an entire batch process</dd></dl></section>
<section class="topic"><h2>Batch Applications :: Old API</h2><p class="statement middle"><strong>?</strong></p></section>
<section class="topic"><h2>Batch Applications</h2><img class="middle" src="images/56-batch-processing.png" alt="Batch processing" width="700"></section>
<section class="topic source"><h2>Batch Applications</h2><div class="listingblock"><pre class="highlight"><code class="xml">&lt;job id="myJob" xmlns="http://batch.jsr352/jsl"&gt; <i class="conum" data-value="1"></i><b>(1)</b>
  &lt;step id="myStep"&gt; <i class="conum" data-value="2"></i><b>(2)</b>
    &lt;chunk reader="MyItemReader" <i class="conum" data-value="3"></i><b>(3)</b>
        writer="MyItemWriter"
        processor="MyItemProcessor"
        buffer-size="5"
        checkpoint-policy="item"
        commit-interval="10" /&gt;
  &lt;/step&gt;
&lt;/job&gt;</code></pre></div>
<div class="colist arabic"><table><tr><td><i class="conum" data-value="1"></i><b>1</b></td><td>Define a job</td></tr><tr><td><i class="conum" data-value="2"></i><b>2</b></td><td>Split it into one or more steps</td></tr><tr><td><i class="conum" data-value="3"></i><b>3</b></td><td>Process each step as a chunk</td></tr></table></div></section>
<section class="topic source"><h2>Batch Applications</h2><div class="listingblock"><div class="title"><code>MyItemReader.java</code></div><pre class="highlight"><code class="java">@ItemReader <i class="conum" data-value="1"></i><b>(1)</b>
public class MyItemReader {
   //...
}</code></pre></div>
<div class="listingblock"><div class="title"><code>MyItemProcessor.java</code></div><pre class="highlight"><code class="java">@ItemProcessor <i class="conum" data-value="2"></i><b>(2)</b>
public class MyItemProcessor {
   //...
}</code></pre></div>
<div class="listingblock"><div class="title"><code>MyItemWriter.java</code></div><pre class="highlight"><code class="java">@ItemWriter <i class="conum" data-value="3"></i><b>(3)</b>
public class MyItemWriter {
   //...
}</code></pre></div>
<div class="colist arabic"><table><tr><td><i class="conum" data-value="1"></i><b>1</b></td><td>Reads Job elements</td></tr><tr><td><i class="conum" data-value="2"></i><b>2</b></td><td>Processes</td></tr><tr><td><i class="conum" data-value="3"></i><b>3</b></td><td>Writes output</td></tr></table></div>
<details><details open=""><p>Opowiedzieć o ilości boilerplate code. Wszystko objęte jest transakcja</p></details></details></section>
<section class="topic"><h2>JEE7 deep dive</h2><ul><li>JMS 2.0</li><li>JPA 2.1</li><li>Bean Validation 1.1</li><li>JAX-RS 2.0</li><li>Java API for JSON Processing</li><li>Java API for Websockets</li><li>Batch Applications</li><li><strong>Concurrency Utilities</strong></li></ul></section>
<section><div class="exampleblock"><div class="content"><blockquote class="small quote"><p>The enterprise bean must not attempt to manage threads. The enterprise bean must not attempt to start, stop, suspend, or resume a thread, or to change a thread’s priority or name. The enterprise bean must not attempt to manage thread groups.</p><br><cite>EJB Spec - 21.2.2. Programming restrictions</cite></blockquote></div></div>
<details><details open=""><p>Kontener musi zapewnić stabilność, pewność, failover – dlatego zarządza wątkami; i nie pozwala innym.
No ale można było w przeszłości działać asynchronicznie / w tle.</p></details></details></section>
<section class="topic"><h2>Concurrency</h2><ul class="incremental"><li>Extension of Java SE Concurrency Utilities API</li><li>Provide asynchronous capabilities to Java EE application components</li><li>Provides Thread Factories and Executor Services</li></ul></section>
<section class="topic source"><h2>Concurrency :: Old API</h2><div class="listingblock"><div class="title"><code>AsynchronousWatcher.java</code></div><pre class="highlight"><code class="java">@Stateless
public class EventWatcher {

	@Asynchronous <i class="conum" data-value="1"></i><b>(1)</b>
	public void method(FeedEvent event) {
		System.out.println(event);
	}

}</code></pre></div>
<div class="colist arabic"><table><tr><td><i class="conum" data-value="1"></i><b>1</b></td><td>This method is run asynchronously</td></tr></table></div></section>
<section class="topic source"><h2>Concurrency :: Old API</h2><div class="listingblock"><div class="title"><code>AsyncServlet.java</code></div><pre class="highlight"><code class="java">@WebServlet(urlPatterns = "/somepath",
	asyncSupported = true) <i class="conum" data-value="1"></i><b>(1)</b>
public class AsyncServlet extends HttpServlet {

    public void doGet(HttpServletRequest request,
	 HttpServletResponse response)
		throws ServletException, IOException {
		//..
	}
}</code></pre></div>
<div class="colist arabic"><table><tr><td><i class="conum" data-value="1"></i><b>1</b></td><td>The Response is immediate</td></tr></table></div></section>
<section class="topic source"><h2>Concurrency :: New API</h2><div class="listingblock"><div class="title"><code>UsingManagedThreadFactory.java</code></div><pre class="highlight"><code class="java">@Named
public class ThreadManager {

	@Resource
	ManagedThreadFactory mtf; <i class="conum" data-value="1"></i><b>(1)</b>

	public ExecutorService getThreadManager() {
		return new ThreadPoolExecutor(5,10, 10,
			TimeUnit.SECONDS,
			new ArrayBlockingQueue&lt;Runnable&gt;(100),
			mtf);
	}
}
</code></pre></div>
<div class="colist arabic"><table><tr><td><i class="conum" data-value="1"></i><b>1</b></td><td><code>ManagedThreadFactory</code> is an application server resource</td></tr></table></div></section>
<section class="topic source"><h2>Concurrency :: New API</h2><div class="listingblock"><pre class="highlight"><code class="java">@Named
public class ProcessingService {

	public void doLoadsOfStuff(ExecutorService executor) {
		for (int i = 0; i &lt; 50; i++) {
			Runnable worker = new WorkerThread("" + i);
			executor.execute(worker); <i class="conum" data-value="1"></i><b>(1)</b>
		}
		executor.shutdown();
	}
}</code></pre></div></section>
<section><img class="middle" src="images/66-jee7.png" alt="66 jee7" width="600"></section>
<section class="topic"><h2>Learn JEE7 the right way</h2><dl class="incremental"><dt>github.com</dt><dd>Fork <em>javaee7-samples</em> project</dd><dt>choose your example</dt><dd>Take one feature at a time, understand the spec, create an Arquillian test. Run with Wildfly and Glassfish. See how it all works.</dd><dt>push it</dt><dd>Become a part of the community. Push your changes and help others</dd></dl></section>
<section class="topic"><h2>JEE8?</h2><ul class="incremental"><li>JSON-B (JSON binding)</li><li>JCache (JSR 107)</li><li>Adopt JSR</li><li>Open TCK (??)</li><li>More JSP (+ templates), less JSF</li><li>no more EARs (??)</li></ul></section>
<section><figure><img class="stretch-x" src="images/68-questions.jpg" alt="68 questions"><figcaption class="invert">Questions?</figcaption></figure></section>
<section class="topic"><h2>References</h2><ul><li><a href="https://github.com/">https://github.com/</a><ul><li><em>javaee-samples/javaee7-samples</em></li><li><em>kubamarchwicki/jee7-examples</em></li><li><em>kubamarchwicki/presentations</em></li></ul></li><li><a href="https://speakerdeck.com/">https://speakerdeck.com/</a><ul><li><em>kubamarchwicki/jeenext</em></li></ul></li></ul></section>
<section class="topic ending"><h2 class="name">Kuba Marchwicki</h2><p class="footer"><em class="icon-twitter">&#8203;</em> @kubem</p></section><script src="./dzslides/core/dzslides.js"></script><script src="./dzslides/highlight/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad()</script></body></html>